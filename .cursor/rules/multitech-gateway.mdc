---
description: MultiTech Conduit gateway development and deployment guidelines
globs: ["**/mlinux-6/**", "**/mlinux-7/**", "**/build-tarball.sh"]
alwaysApply: false
---

# MultiTech Conduit Gateway Development

## API Documentation

**mPower REST API Reference**: https://multitechsystems.github.io/mpower-api

This documentation covers all gateway REST API endpoints including:
- Authentication and session management
- Firewall configuration
- Custom app management
- Network settings
- LoRa configuration

**Important**: Always check the API documentation for correct endpoint paths. Do not guess API paths.

## Platform Requirements

- **mLinux 6**: Python 3.8 - use `List`, `Dict`, `Optional` type hints
- **mLinux 7**: Python 3.10 - can use `list`, `dict`, `|` type hints
- **No pip**: Don't rely on pip for dependencies - bundle everything or use stdlib
- Use dataclasses for configuration (no pydantic)

## Type Hint Conversion Table

| Python 3.10+ | Python 3.8 |
|--------------|------------|
| `list[str]` | `List[str]` |
| `dict[str, Any]` | `Dict[str, Any]` |
| `str \| None` | `Optional[str]` |
| `int \| str` | `Union[int, str]` |
| `tuple[int, str]` | `Tuple[int, str]` |

For Python 3.8, add `from __future__ import annotations` at top of files.

## Gateway File Structure

```
/var/config/app/{app_name}/
├── config/
│   └── config.json          # App configuration
├── status.json              # Status for app-manager
└── {app_name}/              # Python source files
```

## Gateway UUID Retrieval

```python
from functools import lru_cache

@lru_cache(maxsize=1)
def get_gateway_uuid() -> str:
    """Retrieve MultiTech gateway UUID."""
    # Primary: mts-io sysfs
    try:
        with open("/sys/devices/platform/mts-io/uuid") as f:
            return f.read().strip().lower()
    except FileNotFoundError:
        pass
    # Fallback: DMI product UUID
    try:
        with open("/sys/class/dmi/id/product_uuid") as f:
            return f.read().strip().lower()
    except FileNotFoundError:
        pass
    # Default
    return "00000000-0000-0000-0000-000000000000"
```

## Status Writer Requirements

- Write to `$APP_DIR/status.json` (use APP_DIR environment variable)
- Fields: `pid` (integer), `AppInfo` (string, max 160 chars)
- Update every 10 seconds in background thread
- Atomic writes (temp file + rename)
- Format: `{"pid": 12345, "AppInfo": "Status message @ HH:MM:SS"}`

**Important**: The `pid` field must be an integer (not a string) for app-manager to correctly track the process.

## Syslog Logging Setup

```python
import logging
from logging.handlers import SysLogHandler

def setup_syslog_logging(app_name: str, level: str = "INFO") -> logging.Logger:
    """Configure logging for mLinux syslog."""
    logger = logging.getLogger(app_name)
    logger.setLevel(getattr(logging, level.upper()))
    
    try:
        # mLinux syslog
        handler = SysLogHandler(address="/dev/log")
        handler.ident = f"{app_name}: "
    except (FileNotFoundError, OSError):
        # Fallback for development
        handler = logging.StreamHandler()
    
    formatter = logging.Formatter("%(name)s - %(levelname)s - %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    return logger
```

## paho-mqtt Version Compatibility

Handle both paho-mqtt 1.x and 2.x APIs:

```python
import paho.mqtt.client as mqtt

def create_mqtt_client(client_id: str) -> mqtt.Client:
    """Create MQTT client compatible with paho-mqtt 1.x and 2.x."""
    try:
        # paho-mqtt 2.x
        client = mqtt.Client(
            callback_api_version=mqtt.CallbackAPIVersion.VERSION2,
            client_id=client_id,
        )
    except (TypeError, AttributeError):
        # paho-mqtt 1.x fallback
        client = mqtt.Client(client_id=client_id)
    return client
```

## API Authentication

- Must use cookie-based sessions, NOT Bearer tokens
- Login first, then use cookies for subsequent requests

```bash
# Login and get session cookie
curl -k -s -c /tmp/cookies.txt -X POST "https://{IP}/api/login" \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"yourpassword"}'

# Use cookies for subsequent requests
curl -k -s -b /tmp/cookies.txt ...
```

## Tarball Build Requirements

Include in tarball:
- manifest.json
- Install
- Start
- status.json
- config/
- provisioning/ (if bundling IPK packages)
- {app_name}/ (Python source files)

Output format: `{app_name}-{version}-mlinux{6|7}.tar.gz`

## Install Script Requirements

The `Install` script handles dependency installation and removal. App-manager calls this script with different arguments during the app lifecycle.

### Required Case Statement

```bash
case "$1" in
    install)      # Install dependencies from provisioning/
    remove)       # Remove dependencies (usually skip shared packages)
    postinstall)  # Post-install tasks (firewall rules, directories, etc.)
    postremove)   # Post-remove cleanup
esac
```

### Provisioning Manifest Format

Create `provisioning/p_manifest.json`:

```json
{
  "pkgs": [
    {
      "FileName": "python3-sqlite3_3.10.15-r0.0_cortexa7t2hf-neon.ipk",
      "PkgName": "python3-sqlite3",
      "type": "ipk"
    }
  ]
}
```

### Install Package Loop

```bash
OPKG_CMD_PREFIX="opkg install --force-depends ./provisioning/"
MANIFEST="./provisioning/p_manifest.json"

if [ -f "$MANIFEST" ]; then
    JSONTXT=$(<./provisioning/p_manifest.json)
    PKGCNT=$(echo $JSONTXT | jsparser --count -p /pkgs 2>/dev/null)
    
    for ((i=0; i < PKGCNT; i++)); do
        PKG=$(echo $JSONTXT | jsparser --jsobj -p /pkgs/$i 2>/dev/null)
        PKGNM=$(echo $PKG | jsparser -p /FileName 2>/dev/null)
        PKGTYPE=$(echo $PKG | jsparser -p /type 2>/dev/null)
        
        if [ "$PKGTYPE" == "ipk" ] && [ -f "./provisioning/$PKGNM" ]; then
            PKGCMD=$OPKG_CMD_PREFIX$PKGNM
            eval $PKGCMD
        fi
    done
fi
```

## Start Script Requirements

The `Start` script is called by app-manager to manage the application process.

**CRITICAL**: Do not call app-manager from within the Start script. App-manager calls this script directly - calling app-manager back causes lock issues and hangs.

### Required Functions

| Function | Purpose |
|----------|---------|
| `SetEnv` | Set environment variables (PYTHONPATH, etc.) |
| `CreateAccess` | Create necessary directories |
| `ChangeUser` | Switch user if needed (usually root) |
| `Execute` | Start the process using start-stop-daemon |
| `Start` | Calls SetEnv, CreateAccess, ChangeUser, Execute |
| `Stop` | Stop the process using start-stop-daemon |
| `Restart` | Stop then Start |
| `Reload` | Restart to pick up new configuration |

### Required Case Statement

```bash
case "$1" in
    start)    Start ;;
    stop)     Stop ;;
    restart)  Restart ;;
    reload)   Reload ;;
esac
```

### Environment Variables from App-Manager

| Variable | Description |
|----------|-------------|
| `APP_DIR` | Application directory: `/var/config/app/{app_name}` |
| `CONFIG_DIR` | Config directory: `/var/config/app/{app_name}/config` |
| `APP_ID` | Numeric app ID assigned by app-manager |

### Execute Function Template

```bash
function Execute {
    # Determine config file location
    if [ -f "$CONFIG_DIR/config.json" ]; then
        CONFIG_ARG="-c $CONFIG_DIR/config.json"
    elif [ -f "$APP_DIR/config/config.json" ]; then
        CONFIG_ARG="-c $APP_DIR/config/config.json"
    else
        CONFIG_ARG=""
    fi
    
    # Start the application using start-stop-daemon
    /usr/sbin/start-stop-daemon --start --background \
        --pidfile "$PID" --make-pidfile \
        --startas /bin/bash -- -c "cd $APP_DIR && exec python3 -m {app_name} $CONFIG_ARG >> $LOG_FILE 2>&1"
    
    logger -t Start "{app_name} started"
}
```

### Stop Function Template

```bash
function Stop {
    /usr/sbin/start-stop-daemon --stop -p "$PID" --retry 60
    rm -f "$PID"
    logger -t Start "{app_name} stopped"
}
```

## Custom Apps Configuration API

To enable/disable custom apps via API:

```bash
# Get current config
curl -k -s -b /tmp/cookies.txt "https://{IP}/api/customAppsConfig"

# Enable custom apps
curl -k -s -b /tmp/cookies.txt -X PUT "https://{IP}/api/customAppsConfig" \
  -H "Content-Type: application/json" \
  -d '{"enabled":true}'

# Save configuration
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/command/save" -H "Content-Length: 0"
```

Configuration options:
- `enabled`: Enable/disable custom apps
- `allowed`: Allow custom app installation
- `backupOnInstall`: Backup before installing new apps

## Firewall Rules via API

Create firewall rules programmatically using `/api/filters`. Rules require the `__v` version field.

### Create Firewall Rule

```bash
# Create INPUT rule to allow TCP port 5000
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/filters" \
  -H "Content-Type: application/json" \
  -d '{
    "__v": 2,
    "name": "webapi_example_port_5000",
    "description": "Allow inbound TCP to webapi_example port 5000",
    "enabled": true,
    "chain": "INPUT",
    "target": "ACCEPT",
    "protocol": "TCP",
    "srcAddr": "ANY",
    "srcMask": "",
    "srcPort": "ANY",
    "dstAddr": "ANY",
    "dstMask": "",
    "dstPort": "5000",
    "srcInterface": "ANY",
    "dstInterface": "ANY",
    "srcSpecInterface": "",
    "dstSpecInterface": "",
    "srcMac": "ANY"
  }'

# Save AND apply configuration (required to activate iptables rules)
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/command/save_apply" \
  -H "Content-Length: 0"
```

**Important**:
- The `__v` field is required. Use `__v: 2` for current mLinux 7 firmware
- After creating/modifying firewall rules, you MUST call `/api/command/save_apply` to persist AND activate the rules
- `/api/command/save` alone only persists to config - rules won't be active until `save_apply` or reboot
- From localhost (127.0.0.1), API requests work without authentication (useful in Install scripts)

### Delete Firewall Rule

```bash
curl -k -s -b /tmp/cookies.txt -X DELETE "https://{IP}/api/filters/{rule_name}"
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/command/save_apply" -H "Content-Length: 0"
```

### List Firewall Rules

```bash
curl -k -s -b /tmp/cookies.txt "https://{IP}/api/filters"
```

## Deployment Commands

### Check Status
```bash
ssh admin@{IP} "app-manager --command status"
```

### View Logs
```bash
ssh admin@{IP} "grep {app} /var/log/messages | tail -50"
```

### View status.json
```bash
ssh admin@{IP} "cat /var/config/app/{app_name}/status.json"
```

### Stop/Start App via API
```bash
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/customApps/{ID}/stop" -H "Content-Length: 0"
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/customApps/{ID}/start" -H "Content-Length: 0"
```

## Install New Application via API

The `appId` in `app_install` must be numeric (e.g., "1", "14") or hexadecimal with hyphens. App names are not valid.

```bash
# 1. Login and get session cookie
curl -k -s -c /tmp/cookies.txt -X POST "https://{IP}/api/login" \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"yourpassword"}'

# 2. Get file size for pre-upload
FILESIZE=$(stat -c%s {app_name}-{version}-mlinux7.tar.gz)

# 3. Pre-upload notification
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/command/app_pre_upload" \
  -H "Content-Type: application/json" \
  -d "{\"info\":{\"fileName\":\"{app_name}-{version}-mlinux7.tar.gz\",\"fileSize\":$FILESIZE}}"

# 4. Upload the tarball
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/command/app_upload" \
  -F "archivo=@{app_name}-{version}-mlinux7.tar.gz;filename={app_name}-{version}-mlinux7.tar.gz;type=application/x-gzip"

# 5. Install the app
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/command/app_install" \
  -H "Content-Type: application/json" \
  -d '{"info":{"appId":"{ID}","appFile":"{app_name}-{version}-mlinux7.tar.gz"}}'

# 6. Start the app
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/customApps/{ID}/start" \
  -H "Content-Length: 0"
```

## Upload and Deploy New Version via SSH

```bash
# 1. Build tarball
cd mlinux-7 && bash build-tarball.sh

# 2. Upload tarball
sshpass -p 'yourpassword' scp mlinux-7/{app_name}-{version}-mlinux7.tar.gz \
  admin@{IP}:/tmp/

# 3. Stop app
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/customApps/{ID}/stop" \
  -H "Content-Length: 0"

# 4. Extract tarball (permission warnings are OK)
sshpass -p 'yourpassword' ssh admin@{IP} \
  "cd /var/config/app/{app_name} && tar -xzf /tmp/{app_name}-{version}-mlinux7.tar.gz --overwrite"

# 5. Start app
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/customApps/{ID}/start" \
  -H "Content-Length: 0"
```

## Update Configuration via API

```bash
# Upload config file via API
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/command/app_config_install" \
  -F "appId={ID}" \
  -F "appConfigFile=@config.json;filename=config.json;type=application/json"

# Restart app to apply new config
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/customApps/{ID}/stop" -H "Content-Length: 0"
sleep 2
curl -k -s -b /tmp/cookies.txt -X POST "https://{IP}/api/customApps/{ID}/start" -H "Content-Length: 0"
```

## Troubleshooting

### App Won't Start
If app shows "STARTED" but AppPids is empty and status.json shows "Not started":
- Check logs: `ssh admin@{IP} "grep {app} /var/log/messages | tail -50"`
- Verify Python syntax errors
- Check file permissions

### API Authentication Failed
If getting "401 not logged in" when trying to stop/start app via API:
- Use cookie jar (`-c` to save, `-b` to use) instead of Bearer token
- Ensure login succeeded before subsequent calls

### App-Manager Lock Issues
If getting "Failed to acquire lock on file" when using app-manager:
- Check if Start script is calling app-manager (it should NOT)
- Remove stale lock: `rm /var/run/AppManager.lock`
- Use the web API instead of CLI

### Permission Denied on Extract
If tar shows "Permission denied" and "Cannot change mode" warnings:
- These warnings are usually OK - files still extract
- Verify with `ls -la` or `cat` the file

## Quick Reference

| Action | Command |
|--------|---------|
| Check app status | `ssh admin@{IP} "app-manager --command status"` |
| View status.json | `ssh admin@{IP} "cat /var/config/app/{app}/status.json"` |
| View logs | `ssh admin@{IP} "grep {app} /var/log/messages \| tail -50"` |
| API login | `curl -k -c cookies.txt -X POST "https://{IP}/api/login" -H "Content-Type: application/json" -d '{"username":"admin","password":"pass"}'` |
| Stop app | `curl -k -b cookies.txt -X POST "https://{IP}/api/customApps/{ID}/stop" -H "Content-Length: 0"` |
| Start app | `curl -k -b cookies.txt -X POST "https://{IP}/api/customApps/{ID}/start" -H "Content-Length: 0"` |
| Enable custom apps | `curl -k -b cookies.txt -X PUT "https://{IP}/api/customAppsConfig" -H "Content-Type: application/json" -d '{"enabled":true}'` |
| Save and apply config | `curl -k -b cookies.txt -X POST "https://{IP}/api/command/save_apply" -H "Content-Length: 0"` |
